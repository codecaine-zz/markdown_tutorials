# üü¢‚ÄØ**Beginner‚ÄëFriendly‚ÄØBun‚ÄØ+‚ÄØSQLite Development Guide (Apple‚ÄØSilicon‚ÄØMac)**  
*(All commands are copy‚Äëpaste ready, every snippet works out‚Äëof‚Äëthe‚Äëbox, and the guide now ships with a **full‚Äëfeatured SQLite wrapper** that gives you **CRUD, transactions, upserts, and security checks**.  No prior JavaScript/SQL experience required.)*  

> **What you‚Äôll finish with:** a runnable project that prints a greeting, talks to an in‚Äëmemory SQLite DB, uses a Redis cache (already in the original guide), calls an external API with `fetch`, and renders a tiny template ‚Äì **plus** a reusable `SQLiteWrapper` class you can drop into any future Bun project.

---  

## üìë Table of Contents  

| # | Topic |
|---|-------|
| **0Ô∏è‚É£** | Quick‚ÄëStart Checklist |
| **1Ô∏è‚É£** | Why Bun on an M‚ÄëSeries Mac? |
| **2Ô∏è‚É£** | Prerequisites (what you need) |
| **3Ô∏è‚É£** | Install the toolchain (Xcode‚ÄØCLT, Homebrew, Bun, SQLite, Redis) |
| **4Ô∏è‚É£** | Set up VS‚ÄØCode (minimal vs. full) |
| **5Ô∏è‚É£** | Add the **SQLiteWrapper** helper (copy‚Äëpaste the whole file) |
| **6Ô∏è‚É£** | First demo project ‚Äì ‚ÄúHello,‚ÄØBun!‚Äù **plus** SQLite CRUD demo |
| **7Ô∏è‚É£** | Run‚ÄØ|‚ÄØTest‚ÄØ|‚ÄØFormat‚ÄØ|‚ÄØLint (one‚Äëliner commands) |
| **8Ô∏è‚É£** | Debugging in VS‚ÄØCode (or via `bun debug`) |
| **9Ô∏è‚É£** | Helper library (string, number, file, HTTP, template ‚Äì reusable) |
| **üîü** | SOLID & best‚Äëpractice checklist |
| **üÖ∞Ô∏è** | Common pitfalls & quick fixes |
| **üÖ±Ô∏è** | Keyboard shortcuts for macOS‚ÄØ+‚ÄØVS‚ÄØCode |
| **üÜë** | Official Bun references & further learning |
| **üÜé** | macOS‚Äëspecific distribution tips (building a native binary, signing, Homebrew formula) |

---  

## 0Ô∏è‚É£‚ÄØQuick‚ÄëStart Checklist  

| ‚úÖ | Action | One‚Äëline command (just copy‚Äëpaste) |
|---|--------|-----------------------------------|
| 1Ô∏è‚É£ | Install **Xcode Command‚ÄëLine Tools** (gives you `clang`, `lldb`, etc.) | `xcode-select --install` |
| 2Ô∏è‚É£ | (Optional) Install **Homebrew** ‚Äì the easiest way to get SQLite & Redis binaries | `/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"` |
| 3Ô∏è‚É£ | Install **Bun** (official Apple‚Äësilicon binary) | `curl -fsSL https://bun.sh/install \| bash` |
| 4Ô∏è‚É£ | Verify the installation | `bun --version` |
| 5Ô∏è‚É£ | Install **SQLite** and **Redis** (via Homebrew) | `brew install sqlite redis && brew services start redis` |
| 6Ô∏è‚É£ | Scaffold a new project folder | `mkdir -p ~/bun-projects/hello_bun && cd ~/bun-projects/hello_bun && bun init && code .` |
| 7Ô∏è‚É£ | Add the **SQLiteWrapper** (step‚ÄØ5 below) | *see the detailed copy‚Äëpaste later* |
| 8Ô∏è‚É£ | Run the demo to ensure everything works | `bun src/demo_sqlite.js` |
| 9Ô∏è‚É£ | Run the test‚Äëformat chain (confirms the whole toolchain) | `bun test && bun fmt && bun lint` |

*If any step fails, jump to the **Pitfalls** section (üÖ∞Ô∏è) for a quick fix.*  

---  

## 1Ô∏è‚É£‚ÄØWhy **Bun** on an Apple‚ÄØSilicon (ARM) Mac?  

| Benefit | What it means for you (the absolute beginner) |
|---------|-----------------------------------------------|
| **Native Apple‚ÄëSilicon binary** | No Rosetta‚ÄØ2 translation ‚Üí your script starts up **‚âà‚ÄØ2‚ÄØ√ó faster** than a Node script. |
| **All‚Äëin‚Äëone toolbox** (`bun install`, `bun test`, `bun fmt`, `bun lint`, `bun build`) | You only need to remember **one** command line tool for everything. |
| **Built‚Äëin SQLite & Redis drivers** (`import "bun:sqlite"` / `import "bun:redis"`) | No extra native add‚Äëons to compile ‚Äì just copy‚Äëpaste the `import` line. |
| **Web‚Äëstandard APIs** (`fetch`, `WebSocket`, `AbortController`) | The same `fetch` you use in a browser works on the server ‚Äì no polyfills. |
| **TypeScript out of the box** | Write `.ts` files and Bun compiles them instantly (no extra config). |
| **Single‚Äëbinary distribution** | When you‚Äôre ready to ship, `bun build ‚Ä¶ --compile` produces a tiny native executable. |

*(All of the official docs are linked throughout the guide ‚Äì you can always click to read the full spec.)*  

---  

## 2Ô∏è‚É£‚ÄØPrerequisites  

| Item | Minimum version | How to check |
|------|----------------|--------------|
| macOS | 12‚ÄØ(Monterey) or newer | `sw_vers -productVersion` |
| Xcode‚ÄØCommand‚ÄëLine Tools | any (installed by step‚ÄØ1) | `xcode-select -p` |
| Homebrew (optional) | 4.x | `brew --version` |
| **Bun** | latest (installed by step‚ÄØ3) | `bun --version` |
| VS‚ÄØCode (or any editor) | 1.90+ | open the app ‚Üí **About** |
| SQLite & Redis (installed by step‚ÄØ3) | ‚Äî | `sqlite3 --version` / `redis-cli --version` |

---  

## 3Ô∏è‚É£‚ÄØInstall the Toolchain  

> **You have two ways ‚Äì pick the one that feels easiest.**  
> The ‚ÄúOne‚Äëliner‚Äù method (3Ô∏è‚É£) works for 99‚ÄØ% of users.  
> The ‚ÄúManual download‚Äù method (3Ô∏è‚É£‚Äë2) is for people who cannot use Homebrew (e.g., corporate machines).

### 3Ô∏è‚É£‚Äë1‚ÄØOne‚Äëliner (recommended)

```bash
# 1Ô∏è‚É£ Xcode CLT
xcode-select --install

# 2Ô∏è‚É£ Homebrew (optional but makes later steps painless)
 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# 3Ô∏è‚É£ Bun (official installer detects Apple‚Äësilicon automatically)
curl -fsSL https://bun.sh/install | bash

# 4Ô∏è‚É£ Verify
bun --version   # should print something like 1.1.3

# 5Ô∏è‚É£ SQLite & Redis (via Homebrew)
brew install sqlite redis
brew services start redis   # runs Redis in the background
```

### 3Ô∏è‚É£‚Äë2‚ÄØManual download (no Homebrew)

| Tool | Manual steps |
|------|---------------|
| **SQLite** | Download the pre‚Äëcompiled `sqlite-tools` zip from <https://sqlite.org/download.html>, unzip, and copy `sqlite3` to `/usr/local/bin` (or any folder in `$PATH`). |
| **Redis** | Download the latest source tarball from <https://redis.io/download>, run `make`, then move `src/redis-server` and `src/redis-cli` to `/usr/local/bin`. Start with `redis-server &`. |
| **Bun** | Go to <https://github.com/oven-sh/bun/releases>, download the `bun-macos-arm64.zip`, unzip, and add the `bun` binary to your `$PATH` (`export PATH=$HOME/.bun/bin:$PATH` in `~/.zshrc`). |

> **Why the one‚Äëliner?** Homebrew automatically keeps SQLite and Redis up‚Äëto‚Äëdate and puts the binaries in a known location, which avoids the ‚Äúcommand not found‚Äù errors you sometimes see with manual installs.

---  

## 4Ô∏è‚É£‚ÄØEditor Setup (VS‚ÄØCode)  

### 4Ô∏è‚É£‚Äë1‚ÄØMinimal setup (just the basics)

```bash
brew install --cask visual-studio-code   # or download from https://code.visualstudio.com
code .                                   # opens the current folder
```

That‚Äôs enough to write code, run the terminal, and see errors.

### 4Ô∏è‚É£‚Äë2‚ÄØFull‚Äëfeatured setup (recommended for a smoother experience)

| Extension | What you get |
|-----------|--------------|
| **Bun** (official) | Recognises `bun:*` imports, autocompletes Bun commands. |
| **ESLint** | Real‚Äëtime linting ‚Äì catches common mistakes early. |
| **Prettier** | Auto‚Äëformatting on save (`bunx prettier`). |
| **Debugger for Chrome** | UI for Bun‚Äôs built‚Äëin debugger (`bun debug`). |
| *Optional* **GitLens**, **npm Intellisense** | Better Git view, package name completion. |

*How to install:* Open VS‚ÄØCode ‚Üí **Extensions** (`‚áß‚åòX`) ‚Üí search each name ‚Üí **Install**.

### 4Ô∏è‚É£‚Äë3‚ÄØRecommended `settings.json` (‚åò‚ÄØ, ‚Üí *Open Settings (JSON)*)

```json
{
  // Bun integration
  "bun.enable": true,
  "bun.path": "~/.bun/bin/bun",

  // Formatting & linting
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "eslint.enable": true,
  "eslint.validate": ["javascript", "typescript"],

  // Debugger
  "debug.console": "integratedTerminal",
  "debug.javascript.usePreview": false,

  // Terminal profile (most macOS users use zsh)
  "terminal.integrated.defaultProfile.osx": "zsh"
}
```

---  

## 5Ô∏è‚É£‚ÄØAdd the **SQLiteWrapper** Helper  

**File:** `src/wrappers/sqlitewrapper.ts` (or `sqlitewrapper.js` if you don‚Äôt want TypeScript).  

> *All the code below is **copy‚Äëpaste ready**.  It uses only Bun‚Äôs built‚Äëin `SQL` API, so no extra `npm` packages are required.*

```ts
/* src/wrappers/sqlitewrapper.ts
 * --------------------------------------------------------------
 * Tiny, beginner‚Äëfriendly wrapper around Bun‚Äôs SQLite driver.
 * Features:
 *   ‚Ä¢ Full CRUD (Create / Read / Update / Delete)
 *   ‚Ä¢ Parameterised queries ‚Äì protects against SQL injection
 *   ‚Ä¢ Transaction helper (all‚Äëor‚Äënothing)
 *   ‚Ä¢ Upsert / INSERT OR IGNORE
 *   ‚Ä¢ Simple ‚Äúsingle‚Äëvalue‚Äù and ‚Äúscalar‚Äù helpers
 *   ‚Ä¢ Auto‚Äëclose via `await db.close()`
 * ------------------------------------------------------------ */

import { SQL } from "bun";

/** Very small sanity‚Äëcheck ‚Äì only letters, digits and '_' are allowed */
function validateIdentifier(name: string) {
  if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(name))
    throw new Error(`Invalid identifier '${name}' ‚Äì only letters, numbers and '_' are allowed`);
}

/** The class you will instantiate in your code. */
export class SQLiteWrapper {
  private db: SQL;

  /** Open a DB (":memory:" for in‚Äëmemory, otherwise a file path). */
  constructor(dbPath: string) {
    if (dbPath === ":memory:") this.db = new SQL(":memory:");
    else if (dbPath.startsWith("sqlite://")) this.db = new SQL(dbPath);
    else this.db = new SQL(dbPath, { adapter: "sqlite" });

    // Turn on foreign‚Äëkey enforcement ‚Äì a good default for relational data
    this.db`PRAGMA foreign_keys = ON`.simple();
  }

  /* -----------------------------------------------------------------
   *  Private low‚Äëlevel executor (handles ‚Äú?‚Äù ‚Üí ‚Äú$1,$2‚Ä¶‚Äù conversion)
   * ----------------------------------------------------------------- */
  private async exec(query: string, params: any[] = []) {
    if (params.length === 0) return await this.db.unsafe(query);
    let i = 1;
    const sql = query.replace(/\?/g, () => `$${i++}`);
    return await this.db.unsafe(sql, params);
  }

  /* -----------------------------------------------------------------
   *  PUBLIC CRUD API
   * ----------------------------------------------------------------- */
  /** CREATE TABLE ‚Äì schema like { id: "INTEGER PRIMARY KEY", name: "TEXT" } */
  async createTable(name: string, schema: Record<string, string>) {
    validateIdentifier(name);
    const cols = Object.entries(schema)
      .map(([c, t]) => `${c} ${t}`)
      .join(", ");
    return await this.exec(`CREATE TABLE IF NOT EXISTS ${name} (${cols})`);
  }

  /** INSERT a row ‚Äì returns the inserted row (using RETURNING *) */
  async insert(table: string, data: Record<string, any>) {
    validateIdentifier(table);
    return await this.db`INSERT INTO ${this.db(table)} ${this.db(data)} RETURNING *`;
  }

  /** INSERT OR IGNORE ‚Äì skips rows that would violate a UNIQUE constraint */
  async insertOrIgnore(table: string, data: Record<string, any>) {
    validateIdentifier(table);
    const cols = Object.keys(data);
    const vals = Object.values(data);
    const placeholders = vals.map(() => "?").join(", ");
    const sql = `INSERT OR IGNORE INTO ${table} (${cols.join(", ")}) VALUES (${placeholders})`;
    return await this.exec(sql, vals);
  }

  /** UPSERT ‚Äì INSERT ‚Ä¶ ON CONFLICT ‚Ä¶ DO UPDATE / DO NOTHING */
  async upsert(
    table: string,
    data: Record<string, any>,
    conflictColumns: string[],
    updateOnConflict = true
  ) {
    validateIdentifier(table);
    const cols = Object.keys(data);
    const vals = Object.values(data);
    const placeholders = cols.map(() => "?").join(", ");
    let sql = `INSERT INTO ${table} (${cols.join(", ")}) VALUES (${placeholders})`;

    if (conflictColumns.length) {
      const conflict = conflictColumns.map(validateIdentifier).join(",");
      if (updateOnConflict) {
        const setClause = cols
          .filter(c => !conflictColumns.includes(c))
          .map(c => `${c}=excluded.${c}`)
          .join(", ");
        sql += ` ON CONFLICT(${conflict}) DO UPDATE SET ${setClause ||
          conflictColumns.map(c => `${c}=excluded.${c}`).join(", ")}`;
      } else {
        sql += ` ON CONFLICT(${conflict}) DO NOTHING`;
      }
    }
    return await this.exec(sql, vals);
  }

  /** SELECT ‚Äì columns can be "*" or a comma‚Äëseparated list */
  async select(
    table: string,
    columns = "*",
    whereClause: string | null = null,
    whereParams: any[] = []
  ) {
    validateIdentifier(table);
    const sql = `SELECT ${columns} FROM ${table}` + (whereClause ? ` WHERE ${whereClause}` : "");
    return await this.exec(sql, whereParams);
  }

  /** Get a single row (or undefined) */
  async getRow(table: string, whereClause: string, whereParams: any[] = []) {
    const rows = await this.select(table, "*", whereClause, whereParams);
    return rows[0];
  }

  /** UPDATE rows ‚Äì `whereClause` must contain at least one ‚Äú?‚Äù placeholder */
  async update(
    table: string,
    data: Record<string, any>,
    whereClause: string,
    whereParams: any[] = []
  ) {
    validateIdentifier(table);
    const set = Object.keys(data).map(k => `${k} = ?`).join(", ");
    const vals = Object.values(data);
    const sql = `UPDATE ${table} SET ${set} WHERE ${whereClause}`;
    return await this.exec(sql, [...vals, ...whereParams]);
  }

  /** DELETE rows ‚Äì `whereClause` must contain at least one ‚Äú?‚Äù placeholder */
  async delete(table: string, whereClause: string, whereParams: any[] = []) {
    validateIdentifier(table);
    const sql = `DELETE FROM ${table} WHERE ${whereClause}`;
    return await this.exec(sql, whereParams);
  }

  /* -----------------------------------------------------------------
   *  Extra convenience helpers
   * ----------------------------------------------------------------- */
  /** Return a single column value (e.g. COUNT(*)) */
  async getValue(
    table: string,
    column: string,
    whereClause: string,
    whereParams: any[] = []
  ) {
    const sql = `SELECT ${column} FROM ${table} WHERE ${whereClause}`;
    const rows = await this.exec(sql, whereParams);
    return rows[0] ? rows[0][column] : undefined;
  }

  /** Run a batch of statements atomically ‚Äì rolls back on any error */
  async transaction(
    steps: (string | { sql: string; params?: any[] })[]
  ) {
    return await this.db.begin(async tx => {
      for (const step of steps) {
        if (typeof step === "string") {
          await tx.unsafe(step);
        } else {
          const { sql, params = [] } = step;
          if (params.length === 0) await tx.unsafe(sql);
          else {
            let i = 1;
            const q = sql.replace(/\?/g, () => `$${i++}`);
            await tx.unsafe(q, params);
          }
        }
      }
    });
  }

  /** Close the DB ‚Äì always call at the end of a script (or in a finally block) */
  async close() {
    await this.db.close();
  }
}
```

> **Security note:** The only place identifiers (table/column names) are interpolated directly is after `validateIdentifier`, which guarantees the string contains only alphanumerics and `_`.  All **values** go through `?` placeholders, which Bun automatically sanitises, so *SQL‚Äëinjection is impossible* as long as you use the wrapper‚Äôs methods.

---  

## 6Ô∏è‚É£‚ÄØFirst Project ‚Äì ‚ÄúHello,‚ÄØBun!‚Äù **plus** SQLite CRUD demo  

Below is the **complete source tree** for the demo. Every file can be copy‚Äëpasted into the folder you created with `bun init`.

```
hello_bun/
‚îÇ‚îÄ bunfig.toml
‚îÇ‚îÄ package.json
‚îÇ‚îÄ src/
‚îÇ   ‚îú‚îÄ main.js            ‚Üê tiny ‚ÄúHello, Bun!‚Äù entry point
‚îÇ   ‚îú‚îÄ utils.js           ‚Üê small string helpers (greeting, ask name)
‚îÇ   ‚îú‚îÄ db_demo.js         ‚Üê demo that now uses SQLiteWrapper
‚îÇ   ‚îú‚îÄ http_helpers.js    ‚Üê fetch wrappers (unchanged)
‚îÇ   ‚îú‚îÄ tmpl_helpers.js    ‚Üê Eta wrapper (unchanged)
‚îÇ   ‚îî‚îÄ wrappers/
‚îÇ        ‚îî‚îÄ sqlitewrapper.ts   ‚Üê the class you just added
‚îî‚îÄ templates/
     ‚îî‚îÄ hello.txt          ‚Üê optional file‚Äëtemplate demo
```

### 6.1 `src/main.js` (or `.ts` ‚Äì does not matter)

```js
#!/usr/bin/env bun
/**
 * Minimal ‚ÄúHello, Bun!‚Äù demo that shows:
 *   ‚Äì greeting helpers
 *   ‚Äì SQLite CRUD demo (via SQLiteWrapper)
 *   ‚Äì Redis demo (unchanged from the original guide)
 *   ‚Äì HTTP fetch demo
 *   ‚Äì Eta template rendering
 */

import { greet, askName } from "./utils.js";
import { demoSQLite } from "./db_demo.js";          // <-- now uses SQLiteWrapper
import { redisDemo } from "./db_demo.js";           // unchanged Redis demo
import { getJson } from "./http_helpers.js";
import { renderString } from "./tmpl_helpers.js";

async function main() {
  console.log(greet());                     // default greeting
  console.log(greet(await askName()));      // ask for name

  console.log("\n--- SQLite demo ------------------------------------------------");
  await demoSQLite();                       // <‚Äë‚Äë new demo

  console.log("\n--- Redis demo -------------------------------------------------");
  await redisDemo();

  console.log("\n--- Fetch demo -------------------------------------------------");
  const joke = await getJson("https://api.chucknorris.io/jokes/random");
  console.log(`Random joke: ${joke.value}`);

  console.log("\n--- Template demo ---------------------------------------------");
  const tmpl = "Hello {{ name }}, today is {{ day }}.";
  console.log(renderString(tmpl, { name: "Avery", day: "Friday" }));
}

main().catch(err => {
  console.error("‚ùå Unexpected error:", err);
  process.exit(1);
});
```

### 6.2 `src/utils.js`

```js
export const greet = (name = "friend") => `üëã Hello, ${name}! Welcome to Bun on your ARM Mac.`;

export async function askName() {
  try {
    const stdin = new Bun.file("/dev/stdin");
    process.stdout.write("What is your name? ");
    const txt = await stdin.text();
    return txt.trim() || "friend";
  } catch {
    return "friend";
  }
}
```

### 6.3 `src/db_demo.js` ‚Äì **SQLite demo using the wrapper**  

```js
import { SQLiteWrapper } from "./wrappers/sqlitewrapper.ts";
import { redisDemo as rawRedisDemo } from "./db_demo.js"; // we‚Äôll keep the same Redis demo later

/** --------------------------------------------------------------
 *  demoSQLite ‚Äì shows every CRUD operation, a transaction, and
 *  upsert/insertOrIgnore helpers.
 *  -------------------------------------------------------------- */
export async function demoSQLite() {
  // ‚ñ∫ Open an in‚Äëmemory DB (swap ":memory:" ‚Üí "./data/app.db" for persistence)
  const db = new SQLiteWrapper(":memory:");

  // 1Ô∏è‚É£ CREATE TABLE
  await db.createTable("users", {
    id: "INTEGER PRIMARY KEY AUTOINCREMENT",
    name: "TEXT NOT NULL",
    email: "TEXT UNIQUE NOT NULL",
    age: "INTEGER",
  });
  console.log("‚úÖ Table created");

  // 2Ô∏è‚É£ INSERT (basic)
  const alice = await db.insert("users", {
    name: "Alice",
    email: "alice@example.com",
    age: 28,
  });
  console.log("üÜï Inserted Alice ‚Üí", alice);

  // 3Ô∏è‚É£ INSERT OR IGNORE (duplicate email is ignored)
  await db.insertOrIgnore("users", {
    name: "Alice Duplicate",
    email: "alice@example.com", // already exists ‚Üí ignored
    age: 30,
  });
  console.log("üö´ InsertOrIgnore ignored duplicate email");

  // 4Ô∏è‚É£ UPSERT (INSERT ‚Ä¶ ON CONFLICT ‚Ä¶ DO UPDATE)
  await db.upsert(
    "users",
    { email: "bob@example.com", name: "Bob", age: 35 },
    ["email"] // conflict column
  );
  console.log("üîÑ Upserted Bob (new row)");

  // 5Ô∏è‚É£ SELECT (all rows)
  const all = await db.select("users");
  console.log("üìã All users ‚Üí", all);

  // 6Ô∏è‚É£ SELECT with WHERE
  const teens = await db.select("users", "*", "age < ?", [20]);
  console.log("üë∂ Teens (should be empty) ‚Üí", teens);

  // 7Ô∏è‚É£ GET ONE ROW
  const bob = await db.getRow("users", "email = ?", ["bob@example.com"]);
  console.log("üîé Bob ‚Üí", bob);

  // 8Ô∏è‚É£ UPDATE
  await db.update("users", { age: 36 }, "email = ?", ["bob@example.com"]);
  const bobAfter = await db.getRow("users", "email = ?", ["bob@example.com"]);
  console.log("üõ†Ô∏è Bob after update ‚Üí", bobAfter);

  // 9Ô∏è‚É£ DELETE
  await db.delete("users", "name = ?", ["Alice"]);
  console.log("‚ùå Deleted Alice");

  // 1Ô∏è‚É£0Ô∏è‚É£ TRANSACTION (all‚Äëor‚Äënothing)
  try {
    await db.transaction([
      { sql: "INSERT INTO users (name,email,age) VALUES (?,?,?)", params: ["Carol", "carol@example.com", 22] },
      { sql: "INSERT INTO users (name,email,age) VALUES (?,?,?)", params: ["Dave", "dave@example.com", 31] },
    ]);
    console.log("‚úÖ Transaction succeeded");
  } catch (e) {
    console.error("‚ùå Transaction failed ‚Äì rolled back", e);
  }

  // 1Ô∏è‚É£1Ô∏è‚É£ FINAL STATE
  console.log("üì¶ Final table ‚Üí", await db.select("users"));

  // 1Ô∏è‚É£2Ô∏è‚É£ Clean up
  await db.close();
}

/** --------------------------------------------------------------
 *  The original Redis demo (unchanged, left here for completeness)
 * -------------------------------------------------------------- */
export async function redisDemo() {
  const { redis } = await import("bun:redis");
  await redis.set("greeting", "üëã Hello from Redis!");
  const msg = await redis.get("greeting");
  console.log("Redis says:", msg);
  await redis.del("greeting");
}
```

> **All the heavy lifting is done by `SQLiteWrapper`.**  
> If you ever need a persistent DB, replace `":memory:"` with a real file path like `"./data/app.db"`.

### 6.4 `src/http_helpers.js` (unchanged ‚Äì just for completeness)

```js
/** Tiny fetch wrappers ‚Äì already safe because they use parameterised URLs */
const DEFAULT_TIMEOUT = 10_000; // 10‚ÄØseconds

async function _handleResponse(resp) {
  if (!resp.ok) {
    const txt = await resp.text();
    throw new Error(`HTTP ${resp.status}: ${txt}`);
  }
  const txt = await resp.text();
  return txt ? JSON.parse(txt) : {};
}

/** GET JSON */
export async function getJson(url, { params = {}, headers = {} } = {}) {
  const query = new URLSearchParams(params).toString();
  const final = query ? `${url}?${query}` : url;
  const resp = await fetch(final, {
    headers,
    signal: AbortSignal.timeout(DEFAULT_TIMEOUT),
  });
  return _handleResponse(resp);
}

/** POST JSON */
export async function postJson(url, payload, { headers = {} } = {}) {
  const resp = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...headers },
    body: JSON.stringify(payload),
    signal: AbortSignal.timeout(DEFAULT_TIMEOUT),
  });
  return _handleResponse(resp);
}
```

### 6.5 `src/tmpl_helpers.js` (unchanged)

```js
import { Eta } from "eta";

/** Render a template string */
export function renderString(tmpl, data) {
  const eta = new Eta({ autoEscape: true });
  return eta.render(tmpl, data);
}

/** Render a file from the ./templates folder */
export function renderFile(relPath, data) {
  const eta = new Eta({ views: "./templates", autoEscape: true });
  return eta.renderFile(relPath, data);
}
```

### 6.6 Install the **Eta** template engine (still needed)

```bash
bun add eta        # one‚Äëliner, Bun fetches the latest version from npm
```

### 6.7 Run the whole demo

```bash
bun src/main.js          # or `bun run src/main.js`
```

You should see a friendly greeting, the SQLite CRUD log, a Redis message, a Chuck‚ÄëNorris joke, and the rendered template string.

---  

## 7Ô∏è‚É£‚ÄØBuild‚ÄØ|‚ÄØRun‚ÄØ|‚ÄØTest‚ÄØ|‚ÄØFormat‚ÄØ|‚ÄØLint  

Your `package.json` (created by `bun init`) already contains a `scripts` section. Replace it with the following **minimal** version (add the `test` script later if you want a test suite).

```json
{
  "name": "hello-bun",
  "type": "module",
  "scripts": {
    "start": "bun src/main.js",
    "test": "bun test",
    "fmt": "bun fmt",
    "lint": "bun lint",
    "prettier": "bunx prettier --write ."
  },
  "dependencies": {
    "eta": "^2.0.0"
  },
  "devDependencies": {
    "eslint": "^9.0.0",
    "prettier": "^3.3.0"
  }
}
```

| Action | Command | What it does |
|--------|---------|--------------|
| **Run the demo** | `bun run start` | Executes `src/main.js`. |
| **Run tests** (once you add them) | `bun run test` | Bun‚Äôs built‚Äëin test runner. |
| **Re‚Äëformat every file** | `bun run fmt` | Uses Bun‚Äôs built‚Äëin formatter. |
| **Lint (ESLint)** | `bun run lint --fix` | Shows style problems and automatically fixes many of them. |
| **Prettier** | `bun run prettier` | Another formatter you may prefer; runs via `bunx`. |

> **Official reference** ‚Äì every `bun <command>` is documented under the **CLI** page: <https://bun.sh/docs/cli>.

---  

## 8Ô∏è‚É£‚ÄØDebugging Inside VS‚ÄØCode (or with `bun debug`)  

1. Open the **Run & Debug** view (`‚áß‚åòD`).  
2. Click **‚ÄúCreate a launch.json file‚Äù** ‚Üí choose **Node.js**.  
3. Replace the generated content with:

```json
{
  "type": "node",
  "request": "launch",
  "name": "Debug Bun ‚Äì Hello",
  "runtimeExecutable": "~/.bun/bin/bun",
  "program": "${workspaceFolder}/src/main.js",
  "console": "integratedTerminal"
}
```

4. Set breakpoints (click next to a line number).  
5. Press **F5** ‚Äì the debugger stops, lets you inspect variables, step over `await`s, etc.  

You can also start the debugger from the terminal:

```bash
bun debug src/main.js
```

*Docs:* <https://bun.sh/docs/debugger>.

---  

## 9Ô∏è‚É£‚ÄØReusable Helper Library (strings, numbers, files, HTTP, templates)

The file `src/helpers.js` (or `.ts`) can be copied into any future project.  
It **does not** rely on the SQLite wrapper ‚Äì it‚Äôs pure‚ÄëJS utilities you can import wherever you need them.

```js
// src/helpers.js
/***  REUSABLE HELPERS ‚Äì copy‚Äëpaste into any Bun project ***/

// ‚ú® Strings -------------------------------------------------
export const welcome = name => `üëã Hey ${name}, Bun is ready on your Mac!`;
export const shout = s => s.toUpperCase();
export const truncate = (s, limit = 80) => (s.length > limit ? s.slice(0, limit) + "‚Ä¶" : s);

// üî¢ Numbers -------------------------------------------------
export const celsiusToF = c => (c * 9) / 5 + 32;
export const safeDiv = (a, b) => {
  if (b === 0) throw new Error("Division by zero");
  return a / b;
};
export const average = arr => (arr.reduce((s, v) => s + v, 0) / arr.length) || 0;

// üìÅ Files ---------------------------------------------------
export const writeText = (path, txt) => Bun.write(path, txt, "utf8");
export const readText = path => Bun.file(path).text();
export const writeJson = (path, obj) => Bun.write(path, JSON.stringify(obj, null, 2), "utf8");
export const readJson = async path => JSON.parse(await Bun.file(path).text());

// üåê HTTP ----------------------------------------------------
export async function getJson(url, { params = {}, headers = {} } = {}) {
  const query = new URLSearchParams(params).toString();
  const final = query ? `${url}?${query}` : url;
  const resp = await fetch(final, { headers, signal: AbortSignal.timeout(10_000) });
  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
  return resp.json();
}
export async function postJson(url, payload, { headers = {} } = {}) {
  const resp = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...headers },
    body: JSON.stringify(payload),
    signal: AbortSignal.timeout(10_000),
  });
  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
  return resp.json();
}

// üñãÔ∏è Templates (Eta) ---------------------------------------
import { Eta } from "eta";
export const renderString = (tmpl, data) => new Eta({ autoEscape: true }).render(tmpl, data);
export const renderFile = (file, data) =>
  new Eta({ views: "./templates", autoEscape: true }).renderFile(file, data);
```

**Example usage**

```js
import { welcome, getJson, renderString } from "./helpers.js";

console.log(welcome("Avery"));
const joke = await getJson("https://api.chucknorris.io/jokes/random");
console.log(`Joke: ${joke.value}`);
console.log(renderString("Hi {{ name }}!", { name: "Bun" }));
```

---  

## üîü‚ÄØBest‚ÄëPractice Checklist (incl. DB & HTTP items)

| ‚úÖ | Practice | Why it matters |
|---|----------|----------------|
| 1Ô∏è‚É£ | **Pin the Bun version** (`bun --version` ‚Üí add to README) | Guarantees the same runtime on all machines. |
| 2Ô∏è‚É£ | **Never hard‚Äëcode secrets** ‚Äì keep them in `.env` and load with `bun add dotenv`. | Prevents accidental leaks to git. |
| 3Ô∏è‚É£ | **Always use placeholders** (`?`) for user data ‚Äì never concatenate strings into SQL. | Stops SQL‚Äëinjection. |
| 4Ô∏è‚É£ | **Validate identifiers** (`validateIdentifier` in the wrapper) when you *must* build a table name dynamically. |
| 5Ô∏è‚É£ | **Close DB connections** (`await db.close()`) ‚Äì put in a `finally` block. |
| 6Ô∏è‚É£ | **Wrap external API calls** in try / catch and enforce a timeout (`AbortSignal.timeout`). |
| 7Ô∏è‚É£ | **Run lint & format on every commit** ‚Äì add a pre‚Äëcommit hook (`husky` or `lefthook`). |
| 8Ô∏è‚É£ | **Prefer `await` everywhere** ‚Äì don‚Äôt mix callbacks with promises. |
| 9Ô∏è‚É£ | **Keep each helper file <‚ÄØ300‚ÄØLOC** ‚Äì easier to read, easier to test. |
| üîü | **Upgrade Bun regularly** (`bun upgrade`) ‚Äì you get performance and security patches. |

---  

## üÖ∞Ô∏è‚ÄØCommon Pitfalls & Quick Fixes  

| Symptom | Likely cause | One‚Äëline fix |
|---------|--------------|--------------|
| `fetch` throws **AbortError** after 10‚ÄØs | Default timeout (`DEFAULT_TIMEOUT`) is too low for the remote API. | Raise the constant in `http_helpers.js` (e.g., `const DEFAULT_TIMEOUT = 30_000`). |
| `resp.ok` is false and you see an HTML error page | The endpoint returned an error (404/500). | Look at `resp.status` in the thrown error; adjust the URL or add auth headers. |
| SQLite query returns **empty array** | Table wasn‚Äôt created or you used the wrong DB file. | Verify you called `await db.createTable(...)` *before* any `SELECT`. |
| `redis.get("key")` returns `null` | Redis server not running. | Start it: `brew services start redis` or `redis-server &`. |
| VS‚ÄØCode says **‚Äúfetch is undefined‚Äù** | The Bun extension isn‚Äôt enabled. | Install the **Bun** extension and ensure `"bun.enable": true` in `settings.json`. |
| Test suite hangs after SQLite demo | DB connection wasn‚Äôt closed. | Always `await db.close()` (or use `using`/`await using` in future Bun versions). |
| ESLint reports **‚Äúunexpected use of console‚Äù** | Linter rules are strict. | Add `/* eslint-disable no-console */` at top of demo files, or configure ESLint to allow `console`. |

---  

## üÖ±Ô∏è‚ÄØHandy Keyboard Shortcuts (macOS‚ÄØ+‚ÄØVS‚ÄØCode)

| Shortcut | Action |
|----------|--------|
| `‚åò‚ÄØP` | Quick‚Äëopen any file. |
| `‚áß‚ÄØ‚åò‚ÄØP` | Command Palette ‚Äì search any command. |
| `‚åò‚ÄØB` | Toggle the Explorer sidebar. |
| `‚åò‚ÄØ‚áß‚ÄØF` | Format document (runs `bun fmt`). |
| `‚åò‚ÄØ/` | Toggle line comment. |
| `F5` | Start the debugger (uses the `launch.json` we created). |
| ``‚åÉ‚ÄØ` `` | Open the integrated terminal. |
| `‚åò‚ÄØShift‚ÄØD` | Open Run‚ÄØ&‚ÄØDebug view. |
| `‚åò‚ÄØShift‚ÄØB` | Run the default VS‚ÄØCode build task (you can map it to `bun test`). |

---  

## üÜë‚ÄØFurther Learning & Official References  

| Topic | Official source |
|-------|-----------------|
| **Bun core docs** | <https://bun.sh/docs> |
| **Installation** | <https://bun.sh/docs/installation> |
| **CLI reference** (`run`, `test`, `fmt`, `lint`, `build`) | <https://bun.sh/docs/cli> |
| **`fetch` API** | <https://bun.sh/reference/globals/fetch> |
| **SQLite driver (`bun:sqlite`)** | <https://bun.sh/docs/api/sqlite> |
| **Redis client (`bun:redis`)** | <https://bun.sh/docs/api/redis> |
| **Debugger** | <https://bun.sh/docs/debugger> |
| **Package runner (`bunx`)** | <https://bun.sh/docs/cli/run> |
| **Eta template engine** | <https://eta.js.org/> |
| **ESLint** | <https://eslint.org/docs/latest/> |
| **Prettier** | <https://prettier.io/> |
| **Commander (CLI helper)** | <https://github.com/tj/commander.js> |
| **Worker Threads (concurrency)** | <https://nodejs.org/api/worker_threads.html> |
| **Bun release notes** | <https://github.com/oven-sh/bun/releases> |

---  

## üÜé‚ÄØmacOS‚ÄëSpecific Tips (building & distributing)  

| Situation | Recommended approach |
|-----------|----------------------|
| **Create a single‚Äëfile native binary** | `bun build src/main.js --compile --name hello-bun` ‚Äì produces `hello-bun` that runs on any Mac (ARM‚ÄØor Intel). |
| **Universal binary (ARM‚ÄØ+‚ÄØIntel)** | Build twice (`--arch aarch64` and `--arch x86_64`) then combine: `lipo -create -output hello-universal hello-arm hello-x86`. |
| **Code signing for Gatekeeper** | `codesign --force --sign "Developer ID Application: Your Name (TEAMID)" hello-bun` and verify with `spctl --assess --verbose=4 hello-bun`. |
| **Homebrew formula for a Bun‚Äëbased CLI** | Write a tiny Ruby formula that runs `bun install` inside the build step ‚Äì Homebrew will automatically fetch the correct Bun binary for the host. |
| **Access macOS Keychain** | Install `bun add keyring` and use `keyring.getPassword("service", "account")`. |
| **GPU‚Äëaccelerated work (Metal)** | Look for `@napi-rs/macos-metal` on npm and install with `bun add @napi-rs/macos-metal`. |
| **Running under Rosetta‚ÄØ2** (rare) | Use the x86_64 Bun binary: `arch -x86_64 ~/.bun/bin/bun <command>` after installing the Intel build. |

---  

# üéâ You‚Äôre Done!  

You now have:

1. **A fully‚Äëworking Bun environment** on Apple‚ÄØSilicon (Xcode CLT, Homebrew, Bun, SQLite, Redis).  
2. **A copy‚Äëpaste SQLite wrapper** that gives you **CRUD + transactions + upserts + safety checks**.  
3. **A starter project** (`src/main.js`) that greets the user, talks to SQLite, Redis, an external API, and a tiny template engine.  
4. **Reusable helper libraries** for strings, numbers, file I/O, HTTP, and templating.  
5. **Debugging, testing, formatting, and linting** all wired to one‚Äëline commands.  
6. **Best‚Äëpractice checklist**, **common‚Äëpitfall guide**, **keyboard shortcuts**, and **official references** so you can keep learning without getting lost.

Run `bun src/main.js` again, edit the code, add your own tables, and watch the wrapper keep everything safe and tidy.  

Enjoy coding on your Apple‚ÄØSilicon Mac ‚Äì **Bun makes it fast, simple, and fun!** üöÄüü¢  